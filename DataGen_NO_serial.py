#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import random as rd


# In[71]:


M = 40    # Size of the alphabet (No of events)
alphabet = []
for k in range(M):
    alphabet.append(str(k))
    

N_emb = 0  # No of serial episodes to be embedded
N = 4    # Length of serial episodes to be embedded
episodes = []
for ep_id in range(N_emb):
    episodes.append([])
    for ev_id in range(N):
        episodes[-1].append(str(ep_id*N+ev_id))


T = 10000   # Desired datastream length
p = 0.02    # geometric parameter that determined the gap between end of an occurrence and the start of the next occurrence of embedded episodes 
eta = 0.5   # geometric parameter that determined the gap between two successive events of an occurrence of embedded episode.


# specs = 'equal'    # This would make each row of the probability transition matrix among event uniform
# specs = 'dense'    # This would load the saved dense probability transition matrix generated by GetprobsMAR_dense.py
specs = 'sparse'     # This would load the saved sparse probability transition matrix generated by GetprobsMAR_sparse.py

if specs != 'equal':
    saved_probs = np.load('Markov_M_'+str(M)+'_probs_'+specs+'.npy')   # Change filename acc to M
#     saved_probs = np.load('Markov_M_20_probs_sparse.npy')   # Change filename acc to M

Probs = {}
for k in range(len(alphabet)):
    Probs[alphabet[k]] = []
    for l in range(len(alphabet)):
        if specs == 'equal':
            Probs[alphabet[k]].append(1/len(alphabet))
        else:
            Probs[alphabet[k]].append(saved_probs[k,l])#1/len(alphabet)

stream = []
if N_emb != 0:
    ep_id = rd.choices(range(N_emb),[1]*N_emb,k=1)[0]
    ev_id = 0
    ep_t = 1 + np.random.geometric(p)
    freqs = [0]*N_emb

stream.append(rd.choices(alphabet,[1]*M,k=1)[0])
    
count = 1

while count < T:
    if N_emb != 0:
        if count == ep_t:
            stream.append(episodes[ep_id][ev_id])
            count += 1
            ev_id += 1
            if ev_id == N:
                freqs[ep_id] += 1
                ep_id = rd.choices(range(N_emb),[1]*N_emb,k=1)[0]
                ev_id = 0
                ep_t = count + np.random.geometric(p)
            else:
                ep_t = count + np.random.geometric(eta)
        else:
            stream.append(rd.choices(alphabet,Probs[stream[-1]],k=1)[0])
            count += 1
    else:
        stream.append(rd.choices(alphabet,Probs[stream[-1]],k=1)[0])
        count += 1

if N_emb == 0:
    name = 'Data/Datastream_M_'+ str(M) + '_n_'+ str(T) + '_probs_' + specs +'.txt'
else:
    name = 'Data/Datastream_M_'+ str(M) + '_n_'+ str(T) + '_emb_' + str(N_emb) + '_N_' + str(N) + '_p_'+ str(p) + '_eta_' + str(eta) + '_probs_' + specs +'.txt'
    print(freqs)


# In[72]:


with open(name,'w') as f:
    for t in range(T):
        f.write(stream[t] + ',' + str(t) + '\n')


# In[ ]:




